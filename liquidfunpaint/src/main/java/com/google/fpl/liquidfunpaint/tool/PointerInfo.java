/**
* Copyright (c) 2014 Google, Inc. All rights reserved.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
package com.google.fpl.liquidfunpaint.tool;

import com.google.fpl.liquidfun.ParticleGroup;
import com.google.fpl.liquidfunpaint.util.Vector2f;

import android.util.Log;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * Maps each pointer ID to the particle group and the coordinate
 * Pointer ID is returned by MotionEvent.getPointerId() and it indicates
 * each separate touch registered.
 * We want each touch (e.g. each finger that is touching the screen) to
 * generate a different ParticleGroup, if it applies.
 * mx, my is the last point generated by user
 */
public class PointerInfo {
    private static final String TAG = "PointerInfo";

    private int mPointerId;
    /**
     * This is stored because we make a new PointerInfo before we are able
     * to get the first worldPoint it should cache (via init()).
     * It also allows us to determine if this is the first time we've seen
     * this pointer id.
     */
    private boolean mNewPointer = true;
    private ParticleGroup mGroup = null;
    private Vector2f mWorldPoint = null;
    private int mBufferBlockStart = -1;
    private int mBufferBlockCurrent = -1;
    private int mNumPoints = 0;

    /**
     * This is a static buffer for storing generated points per pointer.
     * We allow PointerInfo to use this buffer in blocks.
     * Could be implemented as a ring buffer but currently we are going to throw
     * errors on memory overflow.
     */
    private static class PointerInputBuffer {
        private static final int FLUSH_LIMIT = 40;
        // 2 times flush limit for enough padding
        private static final int BLOCK_SIZE = FLUSH_LIMIT * 2;
        // Assume maximum of 40 unique pointers on a screen
        private static final int TOTAL_BUFFER_SIZE = BLOCK_SIZE * 40;
        private ByteBuffer mByteBuffer;
        private int mBufferEnd = 0;

        private PointerInputBuffer() {
            mByteBuffer = ByteBuffer
                    .allocateDirect(TOTAL_BUFFER_SIZE)
                    .order(ByteOrder.nativeOrder());
        }

        private int getNewBlock() {
            int newBlock = mBufferEnd;
            mBufferEnd += BLOCK_SIZE;
            if (mBufferEnd >= TOTAL_BUFFER_SIZE) {
                Log.e(TAG, "Buffer overflow in sGeneratedPoints! " +
                           "Increase buffer size or decrease flush size.");
            }
            return newBlock;
        }

        private int putPoint(int index, Vector2f point) {
            int currIndex = index;
            mByteBuffer.putFloat(currIndex, point.x);
            currIndex += 4;
            mByteBuffer.putFloat(currIndex, point.y);
            currIndex += 4;
            return currIndex;
        }

        private void reset() {
            mByteBuffer.clear();
            mBufferEnd = 0;
        }

        private ByteBuffer getRawBuffer() {
            return mByteBuffer;
        }
    }

    // The actual buffer for storing pointer inputs
    private static PointerInputBuffer sPointerInputBuffer =
            new PointerInputBuffer();

    // Static methods
    protected static void resetGlobalBuffer() {
        sPointerInputBuffer.reset();
    }

    // Member methods
    protected PointerInfo(int pointerId) {
        mPointerId = pointerId;
    }

    protected boolean isNewPointer() {
        return mNewPointer;
    }

    protected int getPointerId() {
        return mPointerId;
    }

    protected ParticleGroup getParticleGroup() {
        return mGroup;
    }

    protected void setParticleGroup(ParticleGroup pGroup) {
        mGroup = pGroup;
    }

    protected int getBufferStart() {
        return mBufferBlockStart;
    }

    protected int getNumPoints() {
        return mNumPoints;
    }

    protected ByteBuffer getRawPointsBuffer() {
        return sPointerInputBuffer.getRawBuffer();
    }

    protected Vector2f getWorldPoint() {
        return mWorldPoint;
    }

    /**
     * Initializes this PointerInfo
     * @param worldPoint The initial point
     * @param storeInput If true, we need to grab a buffer block for storage.
     */
    protected void init(Vector2f worldPoint, boolean storeInput) {
        if (isNewPointer()) {
            mWorldPoint = new Vector2f(worldPoint);
            if (storeInput) {
                mBufferBlockStart = sPointerInputBuffer.getNewBlock();
                mBufferBlockCurrent = mBufferBlockStart;
            }
        }
    }

    /**
     * This updates the PointerInfo after all the processing, per touch event.
     * @param worldPoint Point to set pointerInfo to
     */
    protected void update(Vector2f worldPoint) {
        mNewPointer = false;
        mWorldPoint.set(worldPoint);
        putPoint(worldPoint);
    }

    protected void putPoint(Vector2f point) {
        if (mBufferBlockCurrent != -1) {
            // Error checking
            if ((mBufferBlockCurrent - mBufferBlockStart) >=
                    PointerInputBuffer.BLOCK_SIZE) {
                Log.e(TAG, "Overflow in a PointerInputBuffer block." +
                           "Increase block size or decrease flush limit.");
            } else {
                mBufferBlockCurrent =
                    sPointerInputBuffer.putPoint(mBufferBlockCurrent, point);
                ++mNumPoints;
            }
        }
    }

    protected boolean needsFlush() {
        return ((mBufferBlockCurrent != -1) &&
                ((mBufferBlockCurrent - mBufferBlockStart) >=
                    PointerInputBuffer.FLUSH_LIMIT)
               );
    }

    protected void resetBuffer() {
        mBufferBlockCurrent = mBufferBlockStart;
        mNumPoints = 0;
    }
}
